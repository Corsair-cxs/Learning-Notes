## 顺序容器

### 1.  顺序容器类型

| 容器         | 容器名       | 特点                                                       |
| ------------ | ------------ | ---------------------------------------------------------- |
| vector       | 可变大小数组 | 支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |
| deque        | 双端队列     | 支持快速随机访问。在头尾位置插入、删除很快。               |
| list         | 双向链表     | 只支持双向顺序访问。在任何位置进行插入、删除操作都很快。   |
| forward_list | 单向链表     | 只支持单向顺序访问。在任何位置进行插入、删除操作都很快。   |
| array        | 固定大小数组 | 支持快速随机访问。不能添加或删除元素。                     |
| string       | 字符串       | 随机访问快。在尾部插入、删除快。                           |

### 2. 迭代器

一个迭代器范围由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置（begin和end）。

```c++
list<string>::iterator iter;
iter = l.begin();
auto iter2 = l.begin();			//仅当l是const时，iter2是const_iterator
auto iter3 = l.cbegin();		//iter3是const_iterator
```

`begin` 和 `end` 有多个版本：带 `r` 的版本返回反向迭代器；以 `c` 开头的版本返回const迭代器。

可以将一个普通的 `iterator` 转换为对应的 `const_iterator` ，但反之不行。

当不需要写访问时，应使用 `cbegin` 和`cend` 。

### 3. 容器初始化

#### 将一个容器初始化为另一个容器的拷贝

当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

当传递迭代器参数来拷贝一个范围时，就不要求容器类型相同了。容器中元素类型也可不同，新容器和原容器元素类型只要能进行转换即可。

```c++
vector<cosnt char*> articles = {"a", "an", "the"};
deque<const char*> arti(articles);		//错误，容器类型不匹配
forward_list<string> words(articles.begin(), articles.end());	//正确
deque<string> ar(articles.begin(), it);		//拷贝元素，直到it指向的元素（不包括it指向的元素）
```

#### 与顺序容器大小相关的构造函数

顺序容器提供一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。

```c++
vector<int> vec(10, -1);	//10个int元素，每个都初始化为-1
deque<string> s(10);		//10个元素，每个都是空string
```

如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个元素初始值。

只有顺序容器的构造函数才接受大小参数，关联容器不支持。

### 4. 容器赋值

#### 直接赋值

```c++
c1 = c2;
c1 = {1, 2, 3};		//赋值运算将其左边容器中的全部元素替换为右边容器中元素的拷贝
```

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。

```c++
array<int, 5> a1 = {0, 1, 2, 3, 4};
array<int, 5> a2 = {0};		//所有元素值均为0
a1 = a2;					//替换a1中的元素
a2 = {0};					//错误：不能将一个花括号列表赋予数组
```

由于右边运算对象大小可能与左边运算对象的大小不同，所以不允许用花括号包围的值列表进行赋值（初始化时可以），也不支持assign。

#### 使用assign（仅顺序容器）

顺序容器（array除外）定义了一个名为assign的成员，允许我们从一个不同但是相容的类型赋值，或者从容器的一个子序列赋值。

```c++
list<string> name;
vector<const char*> old;
name = old;									//错误，容器类型不匹配
name.assign(old.cbegin(), old.cend());		//正确
```

对assign的调用将name中的元素替换为迭代器指定的范围中的元素的拷贝。由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。

```c++
list<string> li(1);
li.assign(10, "hi");	
//assgin第二个版本接受一个整型值和一个元素值，用指定数目的元素替换容器中原有元素
```

#### 使用swap

swap操作交换两个相同类型容器的内容

```c++
vector<string> svec1(10);
vector<string> svec2(24);
swap(svec1, svec2);		//swap只是交换了两个容器的内部数据结构
```

除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。与其他容器不同，swap两个array会真正交换它们的元素，因此，交换两个array所需的时间与array中元素的数目成正比。

除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向操作之前所指向的那些元素。但是在swap之后，这些元素已经属于不同的容器了。

对于array，在swap操作后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。

与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

















































