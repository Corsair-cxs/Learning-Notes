## 动态内存

### 1. 各对象生存期

**全局对象** 在程序启动时分配，在程序结束时销毁。

**局部自动对象** 在进入其定义所在的程序块时创建，在离开块时销毁。

**局部static对象** 在第一次使用前分配，在程序结束时销毁。

### 2. 动态对象释放

C++支持动态分配对象。动态对象在 **堆** 中分配空间。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。但是动态对象的正确释放是编程中极易出错的地方。

为了更安全地使用动态对象，标准库定义了两个 **智能指针** 类型来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。

### 3. 动态内存管理

`new` ：在动态内存中为对象分配空间并返回一个指向该对象的指针。

`delete` ：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

### 4. 使用动态内存原因

- 程序不知道自己需要多少对象（例如容器）
- 程序不知道所需要对象的准确类型
- 程序需要在多个对象间共享数据

### 5. 智能指针

**智能指针** 负责自动释放所指向的目标。

新标准库提供的两种智能指针的区别在于管理底层指针的方式：`shared_ptr` 允许多个指针指向同一个对象；`unique_ptr` 独占所指向的对象。`weak_ptr` 是伴随类，是一种弱引用，指向shared_ptr所指向的对象。

三种类型都定义在 `memory` 头文件中。

### 6. shared_ptr

#### make_shared

`make_shared` 标准库函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。

```c++
//指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
//指向一个值为"aaa"的string的shared_ptr
auto p4 = make_shared<string>(3, 'a');
```

make_shared用其参数来构造给定类型的对象；如果不传递任何参数，对象就会进行值初始化。

#### 引用计数

每个shared_ptr都有一个关联的计数器，称之为 **引用计数** 。

拷贝一个shared_ptr时，计数器会递增。如当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给下一个函数以及作为函数的返回值时。

当给shared_ptr赋予一个新值或是shared_ptr被销毁时，计数器会递减。

当一个shared_ptr的 *计数器变为0* ，它就会自动释放自己所管理的对象。

```c++
auto r = make_shared<int>(42);	//r指向的int只有一个引用者
r = q;	//给r赋值，令它指向另一个地址
		//递增q指向对象的引用计数
		//递减r原来指向对象的引用计数
		//r原来指向的对象已没有引用者，会自动释放
```

#### 自动销毁对象并释放内存

当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过 **析构函数** 完成销毁工作的。析构函数控制对象销毁时做什么操作。

shared_ptr还会自动释放相关联的内存。























