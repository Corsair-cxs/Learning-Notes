## 拷贝控制

### 1. 拷贝控制操作

`拷贝和移动构造函数` 定义了当用同类型的另一个对象 **初始化** 本对象时做什么。`拷贝和移动赋值运算符` 定义了将一个对象 **赋予** 同类型的另一个对象时做什么。`析构函数` 定义了当此类型对象销毁时做什么。

### 2. 如何拷贝

对于类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。

### 3. 拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是 **拷贝构造函数** 。

```c++
class Foo {
public:
    Foo();	//默认构造函数
    Foo(const &Foo);	//拷贝构造函数，自身类型引用参数一般是const引用
}
```

#### 合成拷贝构造函数

如果没有为一个类定义拷贝构造函数，编译器会定义一个。合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。

#### 拷贝初始化

直接初始化与拷贝初始化之间的 **差异** ：`直接初始化` 要求编译器使用普通函数匹配来选择构造函数；`拷贝初始化` 则是要求编译器将右侧运算对象拷贝到正在创建的对象中，如需要还要进行类型转换。拷贝初始化通过 `拷贝构造函数` 或 `移动构造函数` 来完成。

```c++
//直接初始化
string dots(10, '.');
string s(dots);
//拷贝初始化
string s2 = dots;
string isbn = "9-999-999";
string nines = string(10, '9');
```

拷贝初始化在下列情况也会发生：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 某些类类型会对它们所分配的对象使用拷贝初始化，如初始化标准库容器或调用insert、push_back成员函数（emplace不同，它是进行直接初始化）。

### 4. 拷贝赋值运算符

#### 重载赋值运算符

**重载运算符** 本质上是函数，其名字由 `operator` 关键字后接表示要定义的运算符的符号组成。

重载赋值运算符的左侧运算对象绑定到隐式的 `this` 参数，右侧运算对象作为显式参数传递。

```c++
class Foo {
public:
    Foo& operator=(const Foo&);	//赋值运算符
}
```

#### 合成拷贝赋值运算符

如果一个类未定义自己的拷贝赋值运算符，编译器会为他生成一个 **合成拷贝赋值运算符** 。它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

```c++
//等价于合成拷贝赋值运算符
Sales_data &Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo;
    revenue = rhs.revenue;
    return *this;
}
```

### 5. 析构函数

**构造函数** ：初始化对象的非static数据成员

**析构函数** ：释放对象使用的资源，并销毁对象的非static数据成员（与构造函数相反）

析构函数是类的一个成员函数，名字由波浪号接类名构成。没有返回值，也不接受参数。不能被重载。

```c++
class Foo {
public:
    ~Foo();	//析构函数
};
```

#### 析构函数执行

**构造函数** ：拥有一个初始化部分和一个函数体。成员初始化在构造函数函数体执行之前完成，且按照它们在类中出现的顺序进行初始化。

**析构函数** ：拥有一个函数体和一个析构部分（隐式的）。首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

智能指针是类类型，有析构函数，在析构阶段会被自动销毁（普通指针不会，即隐式销毁一个内置指针类型的成员不会delete它所指向的对象，所以析构函数里需要delete内置类型指针）。

**注意** ：析构函数体自身不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。

#### 合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个 **合成析构函数** 。

```c++
//等价于合成析构函数
class Sales_data {
public:
    ~Sales_data() { }
};
```

#### 析构函数与拷贝构造函数以及拷贝赋值运算符的关系

如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。

如果一个类需要自定义拷贝赋值运算符，几乎肯定它也需要一个拷贝构造函数。

然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不一定需要析构函数。

### 6. 阻止拷贝

对于某些类来说，拷贝构造函数和拷贝赋值运算符没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或者赋值。（如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲）。

#### 定义删除的函数

**删除的函数** 即：虽声明了它们，但是不能以任何方式使用它们。在函数的参数列表后面加上 `=delete` 来指出它是删除的。

```c++
struct NoCopy {
	NoCpoy() = default;		//使用合成的默认构造函数
    NoCopy(const NoCopy&) = delete;		//阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;	//阻止赋值
    ~NoCopy() = default;	//使用合成的析构函数
};
```

可以对任何函数指定 `=delete` 。（而 `=default` 只能对编译器可以合成的默认构造函数或拷贝控制成员使用）

不能删除析构函数，如果析构函数被消除，就无法销毁此类型的对象了。

**合成的拷贝控制成员可能是删除的** ：如果一个类有数据成员不能默认构造、拷贝、赋值或者销毁，则对应的成员函数将被定义为删除的。

### 7. 拷贝控制

可以定义拷贝操作，使类的行为看起来像一个 **值** 或者像一个 **指针** 。

类的行为像一个 **值** ，意味着它应该有自己的状态。当拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本对原对象不会有任何影响，反之亦然。

行为像 **指针** 的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。（另一个类展现类似指针行为的最好办法是使用shared_ptr，也可以自己定义引用计数）









