## 拷贝控制

### 1. 拷贝控制操作

`拷贝和移动构造函数` 定义了当用同类型的另一个对象 **初始化** 本对象时做什么。`拷贝和移动赋值运算符` 定义了将一个对象 **赋予** 同类型的另一个对象时做什么。`析构函数` 定义了当此类型对象销毁时做什么。

### 2. 如何拷贝

对于类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。

### 3. 拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是 **拷贝构造函数** 。

```c++
class Foo {
public:
    Foo();	//默认构造函数
    Foo(const &Foo);	//拷贝构造函数，自身类型引用参数一般是const引用
}
```

#### 合成拷贝构造函数

如果没有为一个类定义拷贝构造函数，编译器会定义一个。合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。

```c++
//与Sales_data的合成拷贝构造函数等价
Sales_data::Sales_data(const Sales_data &orig):
	bookNo(orig.bookNo), units(orig.units), revenue(orig.revenue) {}
```

#### 拷贝初始化

直接初始化与拷贝初始化之间的 **差异** ：`直接初始化` 要求编译器使用普通函数匹配来选择构造函数；`拷贝初始化` 则是要求编译器将右侧运算对象拷贝到正在创建的对象中，如需要还要进行类型转换。拷贝初始化通过 `拷贝构造函数` 或 `移动构造函数` 来完成。

```c++
//直接初始化
string dots(10, '.');
string s(dots);
//拷贝初始化
string s2 = dots;
string isbn = "9-999-999";
string nines = string(10, '9');
```

拷贝初始化在下列情况也会发生：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
- 某些类类型会对它们所分配的对象使用拷贝初始化，如初始化标准库容器或调用insert、push_back成员函数（emplace不同，它是进行直接初始化）。

### 4. 拷贝赋值运算符

#### 重载赋值运算符

**重载运算符** 本质上是函数，其名字由 `operator` 关键字后接表示要定义的运算符的符号组成。

重载赋值运算符的左侧运算对象绑定到隐式的 `this` 参数，右侧运算对象作为显式参数传递。

```c++
class Foo {
public:
    Foo& operator=(const Foo&);	//赋值运算符
}
```

#### 合成拷贝赋值运算符

如果一个类未定义自己的拷贝赋值运算符，编译器会为他生成一个 **合成拷贝赋值运算符** 。它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

```c++
//等价于合成拷贝赋值运算符
Sales_data &Sales_data::operator=(const Sales_data &rhs) {
    bookNo = rhs.bookNo;
    revenue = rhs.revenue;
    return *this;
}
```

**Tip** ：拷贝赋值运算符执行拷贝构造函数和析构函数的工作。

### 5. 析构函数

**构造函数** ：初始化对象的非static数据成员

**析构函数** ：释放对象使用的资源，并销毁对象的非static数据成员（与构造函数相反）

析构函数是类的一个成员函数，名字由波浪号接类名构成。没有返回值，也不接受参数。不能被重载。

```c++
class Foo {
public:
    ~Foo();	//析构函数
};
```

#### 析构函数执行

**构造函数** ：拥有一个初始化部分和一个函数体。成员初始化在构造函数函数体执行之前完成，且按照它们在类中出现的顺序进行初始化。

**析构函数** ：拥有一个函数体和一个析构部分（隐式的）。首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

智能指针是类类型，有析构函数，在析构阶段会被自动销毁（普通指针不会，即隐式销毁一个内置指针类型的成员不会delete它所指向的对象，所以析构函数里需要delete内置类型指针）。

**注意** ：析构函数体自身不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。

#### 合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个 **合成析构函数** 。

```c++
//等价于合成析构函数
class Sales_data {
public:
    ~Sales_data() { }
};
```

#### 析构函数与拷贝构造函数以及拷贝赋值运算符的关系

如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。

如果一个类需要自定义拷贝赋值运算符，几乎肯定它也需要一个拷贝构造函数。

然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不一定需要析构函数。

### 6. 阻止拷贝

对于某些类来说，拷贝构造函数和拷贝赋值运算符没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或者赋值。（如iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲）。

#### 定义删除的函数

**删除的函数** 即：虽声明了它们，但是不能以任何方式使用它们。在函数的参数列表后面加上 `=delete` 来指出它是删除的。

```c++
struct NoCopy {
	NoCpoy() = default;		//使用合成的默认构造函数
    NoCopy(const NoCopy&) = delete;		//阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;	//阻止赋值
    ~NoCopy() = default;	//使用合成的析构函数
};
```

可以对任何函数指定 `=delete` 。（而 `=default` 只能对编译器可以合成的默认构造函数或拷贝控制成员使用）

不能删除析构函数，如果析构函数被消除，就无法销毁此类型的对象了。

**合成的拷贝控制成员可能是删除的** ：如果一个类有数据成员不能默认构造、拷贝、赋值或者销毁，则对应的成员函数将被定义为删除的。

### 7. 拷贝控制

可以定义拷贝操作，使类的行为看起来像一个 **值** 或者像一个 **指针** 。

类的行为像一个 **值** ，意味着它应该有自己的状态。当拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本对原对象不会有任何影响，反之亦然。

行为像 **指针** 的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。（另一个类展现类似指针行为的最好办法是使用shared_ptr，也可以自己定义引用计数）

### 8. 对象移动

新标准的最主要的特性是可以移动而非拷贝对象的能力。某些情况下，对象拷贝后就立即被销毁了，这些情况下，移动而非拷贝对象会大幅度提升性能。

对于 `IO` 类或者 `unique_ptr` 这样的类，这些类不包含能被共享的资源（如指针或IO缓冲），因此这些类型的对象不能拷贝但可以移动。

新标准中，可以用容器保存不可拷贝的类型，只要它们能被移动即可。

#### 右值引用

**右值引用** 就是必须绑定到右值的引用，通过 `&&` 而不是 `&` 来获取右值引用。

```c++
int i = 42;
int &rr1 = i * 42;	//错误
int &&rr2 = i * 42;	//正确
```

#### 左值和右值

- 一般而言，左值表达式表示的是一个对象的身份，而右值表达式表示的是对象的值
- 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回 **左值** 的表达式的例子。可将左值引用绑定到这类表达式的结果上
- 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。可将一个const的左值引用或者一个右值引用绑定到这类表达式上。
- 右值引用所引用的对象将要被销毁，且该对象没有其他用户。意味着：使用右值引用的代码可以自由地接管所引用的对象的资源
- 变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值。因此不能将一个右值引用绑定到一个右值引用类型的变量上

#### move函数

`move` 函数可用来获得绑定到左值上的右值引用。此函数定义在 `utility` 中。

```c++
int &&rr1 = 42;		//正确，字面常量是右值
int &&rr2 = rr1;	//错误，表达式rr1是左值
int &&rr3 = std::move(rr1);	//正确
```

调用了move，就只能对移后源对象rr1赋值和销毁，不能再使用它的值。

对move不提供using声明，直接调用 `std::move` 。

#### 移动构造函数

移动构造函数的第一个参数是该类型的一个右值引用，其他额外的参数都必须有默认实参。

资源移动完成后，源对象不再指向被移动的资源，这些资源的所有权已经归属新创建的对象。此时，移后源对象处于这样一个状态——销毁它是无害的。

```c++
class StrVec {
public:
    StrVec(StrVec&&) noexcept;
};
//成员初始化结果s中的资源
//移动操作不应抛出任何异常
StrVec::StrVec(StrVec &&s) noexcept 
    : elements(s.elements), first_free(s.first_free), cap(s.cap) {
        s.elements = s.first_free = s.cap = nullptr;
    }
```

与拷贝构造函数不同，移动构造函数不分配新内存，它直接接管给定的StrVec的内存。接管内存后，将给定对象中的指针置为nullptr，完成给定对象的移动操作。

####  移动赋值运算符

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept {
    if (this != &rhs) {
        free();	//释放已有元素
        elements = rhs.elements;	//从rhs接管资源
        first_free = rhs.elements;	
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

#### 合成的移动构造函数和移动赋值运算符

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。

```c++
struct X {
    int i;			//内置类型可以移动
    std::string s;	//string定义了自己的移动操作
};
struct hasX {
    X mem;	//X有合成的移动操作
};
X x, x2 = std::move(x);			//使用合成的移动构造函数
hasX hx, hx2 = std::move(hx);	//使用合成的移动构造函数
```

#### 移动构造函数和拷贝构造函数同时存在

如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则确定使用哪个构造函数。

```c++
StrVec v1, v2;	
v1 = v2;		//v2是左值，使用拷贝赋值
StrVec getVec(istream &);	//返回一个右值
v2 = getVec(cin);		//getVec(cin)返回一个右值，所以使用移动赋值
```

但如果定义了拷贝构造函数，没定义移动构造函数，右值也被拷贝：

```c++
class Foo {
public:
    Foo() = default;
    Foo(const Foo&);	//拷贝构造函数
    //未定义移动构造函数
};
Foo x;
Foo y(x);				//拷贝构造函数，x是一个左值
Foo z(std::move(x));	//拷贝构造函数，因为未定义移动构造函数
```

**区别**：移动构造函数和移动赋值运算符接受一个（通常是非const的）右值引用；而拷贝版本则接受一个（通常是const）的普通左值引用。；

#### 三五法则

一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。（拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数）。

#### 移动迭代器

一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符生成一个右值引用。（一般迭代器解引用运算符返回一个指向元素的左值）。

标准库的 `make_move_iterator` 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。

```c++
auto last = uninitialized_copy(make_move_iterator(old.begin()), make_move_iterator(old.end()), new_vec.begin());
```

uninitialized_copy对输入序列的每一个元素调用construct函数，construct函数在此例中将使用移动构造函数来构造元素。

#### 安全性

当调用 `std::move` 时，必须确认移后源对象没有其他用户。

### 9. 普通成员函数的拷贝和移动版本

区分移动和拷贝的重载函数通常有一个版本接受一个 `const T&` （指向const的左值引用），而另一个版本接受一个 `T&&` （指向非const的右值引用）。

```c++
class StrVec {
public:
    void push_back(const std::string&);	//拷贝元素
    void push_back(std::string&&);		//移动元素
};
void StrVec::push_back(const string &s) {
    alloc.construct(first_free ++, s);
}
void StrVec::push_back(string &&s) {
    alloc.construct(first_fre ++, std::move(s));
}
```

### 10. 右值和左值引用成员函数

在参数列表后放置一个 **引用限定符** `&` 或 `&&` 分别指出this可指向一个左值或右值。

```c++
class Foo {
public:
    Foo &operator=(const Foo&) &;	//只能向可修改的左值赋值
};
Foo &Foo::operator=(const Foo &rhs) & {
    //拷贝操作
    return *this;
}
```

引用限定符只能用于非static成员函数，且必须同时出现在函数的声明和定义当中。

一个函数如果同时有const的引用限定，引用限定符跟在const限定符之后：

```c++
class Foo {
public:
    Foo someMem() const &;
};
```

引用限定符也可以用来区分重载版本。如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。











