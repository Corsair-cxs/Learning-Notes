## 12 - 线程控制

### 1. 线程限制

下图为与 **线程操作** 有关的一些 **限制**：

![](./img/12-341.png)

可以通过 **sysconf** 函数进行查询 。

### 2. 线程属性

可使用 **pthread_attr_t** 结构修改线程默认属性，并把这些属性与创建的线程联系起来。

**初始化** 和 **反初始化**：

```c++
#include <pthread.h>
int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthead_attr_t *attr);
//返回值：若成功，返回0；否则，返回错误编号
```

**POSIX.1** 定义的线程属性有：

![](./img/12-342.png)

#### 2.1 分离状态属性

如果不需要了解线程的终止状态，可以修改 **detachstate** 属性，让线程一开始就处于 **分离状态** ，且让操作系统在线程退出时收回它所占的资源：

```c++
#include <pthread.h>
int pthread_atr_getdetachstate(const pthread_attr_t *restrict attr,
                              int *detachstate);
int pthread_attr_stdetachstate(pthread_attr_t *attr, int *detachstate);
//返回值：若成功，返回0；否则，返回错误编号
//detachstate参数：PTHREAD_CREATE_DETACHED表示以分离状态启动线程
//PTHREAD_CREATE_JOINABLE表示正常启动线程，应用程序可以获取线程的终止状态
```

#### 2.2 线程栈属性

可以使用 **pthread_attr_getstack** 和 **pthread_attr_setstack** 对 **线程栈属性** 进行管理：

```c++
#include <pthread.h>
int pthread_attr_getstack(const pthread_attr_t *restrict attr,
                         void **restrict stackaddr,
                         size_t *restrict stacksize);
int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);
//返回值：若成功，返回0；否则，返回错误编号
```

如果线程栈的虚地址空间都用完了，可以使用 **malloc** 或者 **mmap** 来为可替代的栈分配空间，并用 **pthread_attr_setstack** 函数来改变新建线程的栈位置。$stackaddr$ 参数指定的地址可以用作线程栈的内存范围中的最低可寻址地址。

#### 2.3 栈的最小长度属性

如果希望改变默认的栈大小，又不想自己处理线程栈的分配问题，可通过 **pthread_attr_getstacksize** 和 **pthread_attr_setstacksize** 函数读取或设置线程属性 $stacksize$ ：

```c++
#include <pthread.h>
int pthread_attr_getstacksize(const pthread_attr_t *restrict attr,
                             size_t *restrict stacksize);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
//返回值：若成功，返回0；否则，返回错误编号
```

选择的 $stacksize$ 不能小于 `PTHREAD_STACK_MIN` 。

需要调整栈大小的 **原因** ：

- 需要 **调小** 的原因：对于线程来说，一个进程中的虚地址空间必须被所有的线程栈共享，如果线程很多，以致于线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大小
- 需要 **调大** 的原因：如果线程调用的函数分配了大量的自动变量，或者调用的函数设计许多很深的 **栈帧** ，那么需要的栈的大小可能要不默认的大

#### 2.4 栈的警戒缓冲区属性

线程属性 $guardsize$ 控制着线程末尾之后用以避免栈溢出的扩展内存的大小：

```c++
#include <pthread.h>
int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
                             size_t *restrict guardsize);
int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
//返回值：若成功，返回0；否则，返回错误编号
```

如果修改了线程属性 $stackaddr$ ，系统认为我们将自己管理栈，进而使栈警戒缓冲区机制无效，这等同于把 $guardsize$ 线程属性设为 $0$ 。

如果 $guardsize$ 线程属性被修改了，操作系统可能会把它取为页大小的整数倍。如果线程指针溢出到警戒区域，应用程序就可能通过信号接收到出错信息。

### 3. 互斥量属性











