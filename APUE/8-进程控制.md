## 8 - 进程控制

### 1. 进程标识

每个进程都有一个非负整型表示的 **唯一进程 ID** 。进程 ID 是可复用的（延迟复用算法）。

ID 为 $0$ 的进程通常是调度进程，常常被称为 **交换进程 (swapper)** 。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为 **系统进程** 。

ID 为 $1$ 通常是 **init** 进程，负责在自举内核后启动一个 UNIX 系统。init 进程决不会终止，它是一个普通的用户进程（不是内核中的系统进程），但它以超级用户特权运行。

**获取各种标识符** 的函数：

```c++
#include <unistd.h>
pit_t getpid(void);		//返回值：调用进程的进程ID
pid_t getppid(void);	//返回值：调用进程的父进程ID
uid_t getuid(void);		//返回值：调用进程的实际用户ID
uid_t geteuid(void);	//返回值：调用进程的有效用户ID
gid_t getgid(void);		//返回值：调用进程的实际组ID
gid_t getegid(void);	//返回值：调用进程的有效组ID
```

这些函数都没有出错返回。

### 2. 函数 fork

一个现有的进程可以调用 **fork 函数** 创建一个新进程：

```c++
#include <unistd.h>
pid_t fork(void);
```

**返回值**：子进程返回 $0$ ，父进程返回子进程ID；若出错，返回 $-1$ 。

由 **fork** 创建的新进程被称为 **子进程 (child process)** 。**fork** 函数被调用一次，但是返回两次。

**父进程返回值是子进程ID** 的原因是：一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。

**子进程返回值是 0** 的原因是：一个进程只会有一个父进程，所以子进程总是可以调用 **getppid** 以获得父进程的进程 ID 。

子进程是父进程的 **副本** 。父进程和子进程 **共享正文段** 。

**写时复制 (COW)** 技术使得子进程可与父进程共享 **数据段** 、**栈**、**堆** ，且内核将它们的访问权限改变为 **只读**　。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一 **页** 。

**clone** 系统调用允许调用者控制哪些部分由父进程和子进程共享。

**fork** 之后是父进程先执行还是子进程先执行是不确定的，取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的 **进程间通信** 。

### 3. 文件共享

父进程所有打开 **文件描述符** 都被复制到子进程中。父进程和子进程每个相同的打开描述符 **共享一个文件表项** （所以父子进程共享一个 **文件偏移量**）。

![](./img/8-185.png)

描述符在 **fork** 前打开，之后 **处理文件描述符** 有以下两种常见情况：

- **父进程等待子进程完成**：在这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新。
- **父进程和子进程各自执行不同的程序段**：在这种情况下，在 fork 之后，父进程和子进程各自关闭它们不需要使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的。

父进程与子进程具体 **区别**：

- fork 的返回值不同
- 进程 ID 不同
- 这两个进程的父进程 ID 不同：子进程的父进程 ID 是创建它的进程 ID，而父进程的父进程 ID 不变
- 子进程的 **tms_utime** 、**tms_stime** 、**tms_cutime** 和 **tms_ustime** 的值设置为 $0$ 
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空集

使用 **fork** **失败** 的两个主要原因：

- 系统中已经有了太多的进程（通常意味着某个方面出了问题）
- 该实际用户 ID 的进程总数超过了系统限制

**fork** 的两种用法：

- **一个父进程希望复制自己，使父进程和子进程执行不同的代码段** 。这在网络服务进程中是最常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用 fork，使子进程处理此请求，父进程则继续等待下一个服务请求。
- **一个进程要执行一个不同的程序** 。这对 shell 是常见的情况。这种情况下，子进程从 fork 返回后立即调用 exec。

### 4. 函数 vfork

**vfork** 函数的调用序列和返回值与 **fork** 相同，但两者的语义不同。**vfork** 函数用于创建一个新进程，而该新进程的目的是 **exec** 一个新程序。

**vfork** 与 **fork** 区别：

- **vfork** 不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用 **exec** 或 **exit** ，不过子进程在调用这两个函数之前，会在父进程的空间中运行。
- **vfork** 保证子进程先运行，在它调用 **exec** 或 **exit** 后父进程才可能被调度运行。

### 5. 函数 exit

**进程的五种正常终止方式**：

1. 在 main 函数内执行 **return** 语句，等效于调用 exit 。
2. 调用 **exit** 函数。其操作包括调用各终止处理程序（由 atexit 函数登记的），然后关闭所有标准 I/O 流等。
3. 调用 **_exit** 和 **_Exit** 函数。这两个函数无需运行终止处理程序或信号处理程序，不对标准 I/O 流进行冲洗。
4. 进程最后一个线程在其启动例程中执行 **return** 语句。此时进程以终止状态 $0$ 返回。
5. 进程的最后一个线程调用 **pthread_exit** 函数。

**进程的三种异常终止方式**：

6. 调用 **abort** ，产生 `SIGABRT` 信号。
7. 当进程接收到某些信号。信号可由进程自身（如调用abort）、其他进程或内核产生。
8. 最后一个线程对 **取消 (cancellation)** 请求做出响应。

不管进程如何终止，都会关闭所有打开描述符，释放使用的存储器等。

**终止进程如何通知其父进程是如何终止的？**

- 对于三个终止函数（**exit*、*_exit**、**_Exit**），将其退出状态作为参数传递给函数。
- 对于异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态。
- 任一情况下，父进程都通过 **wait** 或 **waitpid** 函数取得其终止状态。

**若父进程在子进程前终止，如何处理？**

通过 **init** 进程收养：对于父进程已经终止的子进程（ **孤儿进程** ），它们的父进程改变为 **init** 进程。操作过程为：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程 ID 就更改为 $1$ （ init 进程的 ID）。**孤儿进程** 不会有什么危害。

**若子进程在父进程之前终止，父进程如何得到子进程终止状态？**

当终止进程的父进程调用 **wait** 或 **waitpid** 时，可以得到关于终止进程的信息，包括：进程 ID、该进程的终止状态以及该进程使用的 CPU时间总量。

**僵死进程 (zombie)** ：

一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程。僵死进程的资源不会被释放，进程 ID 也一直被占用，但是系统所能使用的进程 ID 是有限的，如果大量地产生僵死进程，将因为没有可用的进程 ID 而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免

**一个由 init 进程收养的进程终止时会变成僵死进程吗？**

不会。因为 **init** 被编写成无论何时只要有一个子进程终止，**init** 就会调用一个 **wait** 函数取得其终止状体。这样也就防止了在系统中塞满僵死进程。

### 6. 函数 wait 和 waitpid

当一个进程正常或异常终止时，内核就向其父进程发送 `SIGCHLD` 信号。子进程终止和内核向父进程发送信号都是异步事件。

调用 **wait** 或 **waitpid** 的函数会：

- 如果其所有的子进程都还在运行，则阻塞。
- 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
- 如果它没有任何子进程，则立即出错返回。

**wait** 和 **waitpid** 函数：

```c++
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
```

**返回值**：若成功，返回进程 ID；若出错，返回 $0$ 或 $-1$ 。

两个函数区别：

- 在一个子进程终止前，**wait** 使其调用者阻塞，而 **waitpid** 有一选项，可使调用者不阻塞。
- **waitpid** 可等待一个特定进程，而 **wait** 则返回任一终止子进程的状态（某一子进程终止，就立即返回）。
- **waitpid** 通过 `WUNTRACED` 和 `WCONTINUD` 选项支持作业控制。
- **wait** 唯一出错情况是没有子进程，对于 **waitpid** ，如果指定的进程或进程组不存在，或者参数 $pid$ 指定的进程不是调用进程的子进程，都可能出错。 

$statloc$ 参数是一个整型指针，终止进程的终止状态存放在它所指向的单元内。若不关心终止状态，可设为空指针。

**终止状态的宏** 定义在 `<sys/wait.h>` 中：

![](./img/8-191.png)

**waitpid** 中 $pid$ 参数作用解释如下：

- $pid==-1$ ：等待任一子进程。此种情况下，**waitpid** 与 **pid** 等效。
- $pid > 0$ ：等待进程 ID 与 $pid$ 相等的子进程。
- $pid==0$ ：等待组 ID 等于调用进程组 ID 的任一子进程。
- $pid < -1$ ：等待组 ID 等于 $pid$ 绝对值的任一子进程。

**waitpid** 的 $options$ 参数作用：

![](./img/8-193.png)









 