## 3 - 文件I/O

### 1. 文件描述符

对于内核而言，所有打开的文件都通过 **文件描述符 (file descriptor)** 引用。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用 `open` 或 `creat` 返回的文件描述符标识该文件，将其作为参数传送给 `read` 或者 `write` 。

UNIX系统shell把 **文件描述符** $0$ 与进程的标准输入（ `STDIN_FILENO` ）关联，**文件描述符** $1$ 与标准输出（ `STDOUT_FILENO` ）关联，**文件描述符** $2$ 与标准错误关联（ `STDERR_FILENO` ）。这些常量在头文件 `<unistd.h>` 中定义。

### 2. 函数 open 和 openat

调用 `open` 或 `openat` 函数可以打开或创建一个文件。

```c++
#include <fcntl.h>
int open(const char *path, int oflag, .../*mode_t mode*/);
int openat(int fd, const char *path, int oflag, .../*mode_t mode*/);
```

**返回值** ：若成功，则返回文件描述符（最小的未用描述符数值）；若失败，fanhui $-1$ 。

**oflag 参数** ：

- `O_RDONLY` ：只读打开，定义为 $0$
- `O_WRONLY` ：只写打开，定义为 $1$
- `O_RDWR` ：读、写打开，定义为 $2$
- `O_APPEND` ：每次都追加到文件尾端
- `O_SYNC` ：使每次 `write` 等待物理 `I/O` 操作完成，包括由该 `write` 操作引起的文件属性更新所需的 `I/O` 。（数据和属性总是同步更新）
- `O_TRUNC` ：如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0

**open 与 openat** 函数关联：

1. $path$ 参数指定的是绝对路径名，在这种情况下，$fd$ 参数被忽略，`openat` 函数相当于 `open` 函数。
2. $path$ 参数指定的是相对路径名，$fd$ 参数指出了相对路径名在文件系统中的开始地址。$fd$ 参数是通过打开相对路径名所在的目录来获取。
3.  $path$ 参数指定了相对路径名，$fd$ 具有特殊值 `AT_FDCWD` 。在这种情况下，路径名在当前工作目录中获取，`openat` 函数在操作上与 `open` 函数类似。

**openat** 函数作用：

1. 让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录
2. 避免 **TOCTTOU (time-of-check-to-time-of-use) 错误** （若有两个基于文件的函数调用，第二个依赖于第一个调用的结果，则这两个调用不具备原子性，两个函数调用之间文件改变，会导致第一个函数调用结果无效）。**[解决原理](https://www.cnblogs.com/liqiuhao/p/9450093.html)**：防止在用相对路径使用访问文件时，不同进程/线程对文件夹访问的竞争。

### 3. 函数 create

可以调用 `create` 函数创建一个新文件。

```c++
#include <fcntl.h>
int create(const char *path, mode_t mode);
```

**返回值** ：若成功，返回为只写打开的文件描述符；若失败，返回 $-1$ 。

此函数等效于：`open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);` ，不需要单独的 `create` 函数。

**缺点**：只能以只写方式打开所创建的文件，必须先调用 `create` 、`close` 再调用 `open` 才可以读新创建的文件。（可用 `open(path, O_RDWR | O_CREAT | O_TRUNC, mode);` 代替）

### 4. 函数 close

可调用 `close` 函数关闭一个打开文件。

```c++
#include <unistd.h>
int close(int fd);
```

**返回值**：若成功，返回 $0$ ；若失败，返回 $-1$ 。

关闭一个文件时还会释放该进程加在该文件上的所有记录锁。

当一个进程终止时，内核会自动关闭它所有的打开文件。

### 5. 函数 lseek

**当前文件偏移量 (current file offset)** 通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个文件时，除非指定 `O_APPEND` 选项，否则该偏移量被设置为 $0$ 。

可调用 `lseek` 函数显示地为一个打开文件设置偏移量。

```c++
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);	//Linux上 off_t 字节数为8
```

**返回值**：若成功，返回新的文件偏移量；若失败，返回 $-1$ （若 $fd$ 指向的是一个管道、FIFO或者网络套接字，则函数返回 $-1$ ，并将 **errno** 设置为 `ESPIPE` ）。

**参数 whence** ：

- 若 $whence$ 是 `SEEK_SET` ( $0$ )，则将该文件的偏移量设置为距文件开始处 $offset$ 个字节
- 若 $whence$ 是 `SEEK_CUR` ( $1$ )，则将该文件的偏移量设置为其当前值加 $offset$ ，$offset$ 可为正或负
- 若 $whence$ 是 `SEEK_END` ( $2$ )，则将该文件的偏移量设置为文件长度加 $offset$ ，$offset$ 可正可负

**确定打开文件的当前偏移量** ：

```c++
off_t curpos;
curpos = lseek(fd, 0, SEEK_CUR);
```

### 6. 函数 read

调用 `read` 函数从打开文件中读数据。

```c++
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
```

**返回值**：读到的字节数，若已到文件尾，返回 $0$ ；若失败，返回 $-1$ 。

返回值必须是一个带符号整型 ( `ssize_t` )，以保证能够返回正整数字节数、$0$ (表示文件尾端) 或 $-1$ (出错) 。

读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。

### 7. 函数 write

调用 `write` 函数向打开文件写数据。

```c++
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
```

**返回值**：若成功，返回已写的字节数；若出错，返回 $-1$ 。

对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了 `O_APPEND` 选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。

### 8. Core Dump

当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做 **Core Dump** 。

程序的主存镜像存放在磁盘的一个文件中以便测试诊断。

### 9. 表示打开文件的三种数据结构

1. 每个进程表项包含一张打开 **文件描述符表** ，每个文件描述符占用一项。与每个文件描述符相关联的是：
   - 文件描述符标志
   - 指向一个文件表项的指针
2. 内核为所有打开文件维持一张 **文件表** 。每个文件表项包含：
   - 文件状态标志（读、写、添写、同步、非阻塞等）
   - 当前文件偏移量
   - 指向该文件v节点的指针
3. 每个打开文件都有一个 **v节点 (v-node)** 结构。v节点包含了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，v节点还包含了该文件的 **i节点 (i-node, 索引节点)** ，i节点包含了文件的所有者、文件长度、指向 文件实际数据块在磁盘上所在位置 的指针等。

![](./img/3-60.png)

**上图**：该进程有两个不同的打开文件，一个文件从标准输入（文件描述符0）打开，另一个从标准输出（文件描述符1）打开。

**v节点作用** ：创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持。这种文件系统称为 **虚拟文件系统** 。

Linux没有将相关数据结构分为 **i节点** 和 **v节点** ，而是采用了一个与文件系统相关的i节点和一个与文件系统无关的i节点。

### 10. 文件共享

![](./img/3-61.png)

**上图** ：两个独立进程各自打开了同一文件，每个进程都获得各自的一个文件表项，但对一个给定文件只有一个v节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己对该文件的当前偏移量。

**文件描述符标志和文件状态标志在作用范围方面的区别**：前者只用于一个进程的一个描述符，而后者则应用于指向该给定文件表项的任何进程中的所有描述符（可能会有多个文件描述符项指向同一文件表项的情况，如 fork 后，父进程、子进程各自的每一个打开文件描述符共享同一个文件表项）。

### 11. 原子操作

























