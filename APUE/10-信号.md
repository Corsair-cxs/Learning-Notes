## 10 - 信号

### 1. 信号

信号是 **软中断** ，信号提供了一种处理异步事件的方法。

每个信号都有一个名字，以 $3$ 个字符 `SIG` 开头，定义在头文件 `<signal.h>` 中。信号名都被定义为 **正整数常量**（信号编号），不存在编号为 $0$ 的信号（空信号）。

产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量（如 errno）来判断是否发生了一个信号，而是必须告诉内核 “在此信号发生时，请执行以下操作” 。

内核进行**信号处理** 有 $3$ 种方式：

1. 忽略此信号。大多数信号都可用这种方式进行处理，但是 `SIGKILL` 和 `SIGSTOP` 不能被忽略，因为它们向内核和超级用户提供了使进程终止或停止的可靠方法。
2. 捕捉信号。通知内核在某种信号发生时，调用一个用户函数，在用户函数中可执行用户希望对这种事件进程的处理。不能捕捉 `SIGKILL` 和 `SIGSTOP` 信号。
3. 执行系统默认动作。对于大多数信号的系统默认动作是终止该进程。**终止+core** 表示在进程当前工作目录的core文件中复制了该进程的内存镜像，UNIX系统调试程序使用core文件检查进程终止时的状态。

### 2. 函数 signal

**signal** 函数用于设置对应信号的处理方式：

```c++
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);
//返回值：若成功，返回 以前 的信号处理配置；若出错，返回 SIG_ERR
```

$signo$ 参数是信号名。

$func$ 的值：

- `SIG_IGN` ，向内核表示忽略此信号
- `SIG_DFL` ，表示接收到此信号后的动作是系统默认动作
- （捕捉该信号）接到此信号后要调用的函数（信号处理程序 或叫 信号捕捉函数）的地址

**返回值** 是一个函数指针，指向在此之前的信号处理程序的指针。

**程序启动** 时，所有信号的状态都是系统默认或忽略。若 **exec** 函数被调用，其将原先设置为要捕捉的信号都更改为默认动作，其他信号状态则不变（一个进程原先要捕捉的信号，当其执行一个新程序后，就不能再捕捉了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义）。

**进程创建** 时，子进程继承父进程的信号处理方式，因为子进程在开始时复制了父进程内存映像。

### 3. 中断的系统调用

如果进程在执行一个 **低速系统调用** 而阻塞期间捕捉到一个信号，则该系统调用被中断。

系统调用分成两类：**低速系统调用** 和 **其他系统调用** ，低速系统调用是可能会使进程永远阻塞的一类系统调用。

**sigaction** 函数使用标志 `SA_RESTART` 允许应用程序请求重启动被中断的系统调用。

**Linux** 系统中，当信号处理程序是用 **signal** 函数时，被中断的系统调用会重启。

自动重启的系统调用包括：**ioctl** 、**read** 、**readv** 、**write** 、**writev** 、**wait** 和 **waitpid** 。前五个函数只有对低俗设备进行操作时才会被信号中断。而 **wait** 和 **waitpid** 在捕捉到信号时总是被中断。



























